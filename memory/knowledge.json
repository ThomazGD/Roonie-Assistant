{
    "estudo sobre valora": {
        "wikipedia": "Claro! Aqui vai uma explicação rápida: 30 de out. de 2023 ... O estudo também aponta que os ... para solucionar problemas sociais e ambientais. © Valora Recicláveis - Desenvolvido por HBA Web Design.",
        "google": "30 de out. de 2023 ... O estudo também aponta que os ... para solucionar problemas sociais e ambientais. © Valora Recicláveis - Desenvolvido por HBA Web Design."
    },
    "estudo sobre mar": {
        "wikipedia": "Vamos lá! Descobri isso: Atividades Desenvolvidas. ENSINO. A FEMAR possui larga tradição no Ensino de atividades voltadas para o conhecimento do mar, iniciada desde a sua fundação em ...",
        "google": "Atividades Desenvolvidas. ENSINO. A FEMAR possui larga tradição no Ensino de atividades voltadas para o conhecimento do mar, iniciada desde a sua fundação em ..."
    },
    "os arquivos pdf": {
        "wikipedia": "Deixa comigo. Veja só: Como juntar arquivos PDF online: · Importe ou arraste e solte seus PDFs em nossa ferramenta de juntar documentos. · Adicione mais PDFs ou os tipos de arquivo ...",
        "google": "Como juntar arquivos PDF online: · Importe ou arraste e solte seus PDFs em nossa ferramenta de juntar documentos. · Adicione mais PDFs ou os tipos de arquivo ..."
    },
    "mlintroductiontomachinelearningwithpython2017pdf": {
        "pdf": "Andreas C. Müller e Sarah Guido\nIntrodução a \nMáquina \nAprendizado \ncom python  \nUm guia para cientistas de dados\nAndreas C. Müller e Sarah Guido\nIntrodução ao aprendizado de máquina\ncom python\nUm guia para cientistas de dados\nBoston\nFarnham\nSebastopol\nTóquio\nPequim\nBoston\nFarnham\nSebastopol\nTóquio\nPequim\n978-1-449-36941-5\n[Lsi]\nIntrodução ao aprendizado de máquina com Python\nPor Andreas C. Müller e Sarah Guido\nCopyright © 2017 Sarah Guido, Andreas Müller. Todos os direitos reservados.\nImpresso nos Estados Unidos da América.\nPublicado pela O'Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\nOs livros de O'Reilly podem ser adquiridos para uso educacional, comercial ou promocional de vendas. As edições online são\nTambém disponível para a maioria dos títulos (http://safaribooksonline.com). Para mais informações, entre em contato com o nosso corporativo/\nDepartamento de Vendas Institucionais: 800-998-9938 ou Corporate@oreilly.com.\nEditor: Dawn Schanafelt\nEditor de produção: Kristen Brown\nCopyEditor: Rachel Head\nRevisor: Jasmine Kwityn\nIndexador: Judy McConville\nDesigner de interiores: David Futato\nDesigner de capa: Karen Montgomery\nIlustrador: Rebecca DeMarest\nOutubro de 2016:\n Primeira edição\nHistórico de revisão para a primeira edição\n2016-09-22: primeiro lançamento\nConsulte http://oreilly.com/catalog/errata.csp?isbn=9781449369415 para obter detalhes de lançamento.\nO logotipo O'Reilly é uma marca registrada da O'Reilly Media, Inc. Introdução ao aprendizado de máquina com\nPython, a imagem da capa e o vestido comercial relacionado são marcas comerciais da O'Reilly Media, Inc.\nEnquanto o editor e os autores tenham usado esforços de boa fé para garantir que as informações e\nAs instruções contidas neste trabalho são precisas, o editor e os autores renunciam a toda a responsabilidade\npor erros ou omissões, incluindo a responsabilidade sem limitação por danos resultantes do uso de\nou dependência deste trabalho. O uso das informações e instruções contidas neste trabalho é por conta própria\nrisco. Se alguma amostras de código ou outra tecnologia, este trabalho contiver ou descrever estiver sujeito a código aberto\nlicenças ou direitos de propriedade intelectual de outras pessoas, é sua responsabilidade garantir que seu uso\nDá está em conformidade com essas licenças e/ou direitos.\nÍndice\nPrefácio. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  vii\n1. Introdução. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1\nPor que aprendizado de máquina?                                                                                                   1\nProblemas O aprendizado de máquina pode resolver 2\nConhecendo sua tarefa e conhecendo seus dados 4\nPor que Python?                                                                                                                      5\nScikit-Learn 5\nInstalando o Scikit-Learn 6\nBibliotecas e ferramentas essenciais 7\nJupyter Notebook 7\nNumpy 7\nScipy 8\nMatplotlib 9\nPANDAS 10\nMcGlearn 11\nPython 2 versus Python 3 12\nVersões usadas neste livro 12\nUma primeira aplicação: Classificação da espécie de íris 13\nAtender aos dados 14\nMedindo sucesso: Dados de treinamento e teste 17\nPrimeiras coisas primeiro: veja seus dados 19\nConstruindo seu primeiro modelo: vizinhos K-Dear mais\nFazendo previsões 22\nAvaliando o Modelo 22\nResumo e Outlook 23\niii\n2. Aprendizagem supervisionada. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25\nClassificação e regressão 25\nGeneralização, excesso de ajuste e subjacência 26\nRelação da complexidade do modelo com o tamanho do conjunto de dados 29\nAlgoritmos de aprendizado de máquina supervisionado 29\nAlguns conjuntos de dados de amostra 30\nVizinhos mais antigos de K 35\nModelos lineares 45\nClassificadores ingênuos Bayes 68\nÁrvores de decisão 70\nConjuntos de árvores de decisão 83\nMáquinas vetoriais de suporte em kernel 92 92\nRedes Neurais (Deep Learning) 104\nEstimativas de incerteza dos classificadores 119\nA função de decisão 120\nPrevendo probabilidades 122\nIncerteza na classificação multiclasse 124\nResumo e Outlook 127\n3. Aprendizagem e pré -processamento não supervisionados. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  131\nTipos de aprendizado não supervisionado 131\nDesafios na aprendizagem não supervisionada 132\nPré -processamento e escala 132\nDiferentes tipos de pré -processamento 133\nAplicando transformações de dados 134\nDados de treinamento e teste de escala da mesma maneira 136\nO efeito do pré -processamento na aprendizagem supervisionada 138\nRedução de dimensionalidade, extração de recursos e aprendizagem de múltiplas\nAnálise de componentes principais (PCA) 140\nFator de matriz não negativa (NMF) 156\nAprendizagem múltipla com t-sne 163\nAgrupamento 168\nK-Means Clustering 168\nAglomeramento aglomerativo 182\nDbscan 187\nComparando e avaliando algoritmos de cluster 191 191\nResumo dos métodos de cluster 207\nResumo e Outlook 208\n4. Representando os recursos de dados e engenharia. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  211\nVariáveis ​​categóricas 212\nCodificação em um hot (variáveis ​​dummy) 213\n4 \n| \nÍndice\nOs números podem codificar categóricos 218\nBinning, discretização, modelos lineares e árvores 220\nInterações e Polinômios 224\nTransformações não lineares univariadas 232\nSeleção automática de recursos 236\nEstatísticas univariadas 236\nSeleção de recursos baseada em modelo 238\nSeleção de recursos iterativos 240\nUtilizando conhecimento especializado 242\nResumo e Outlook 250\n5. Avaliação e melhoria do modelo. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  251\nValidação cruzada 252\nValidação cruzada no Scikit-Learn 253\nBenefícios da validação cruzada 254\nValidação cruzada estratificada e outras estratégias 254\nPesquisa de grade 260\nPesquisa de grade simples 261\nO perigo de ajustar demais os parâmetros e o conjunto de validação 261\nPesquisa de grade com validação cruzada 263\nMétricas de avaliação e pontuação 275\nMantenha o objetivo final em mente 275\nMétricas para classificação binária 276\nMétricas para classificação multiclasse 296\nMétricas de regressão 299\nUsando métricas de avaliação na seleção de modelos 300\nResumo e Outlook 302\n6. Correntes de algoritmo e oleodutos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  305\nSeleção de parâmetros com pré -processamento 306\nOleodutos de construção 308\nUsando oleodutos em pesquisas de grade 309\nA interface geral de pipeline 312\nCriação de pipeline conveniente com Make_piPeline 313\nAcessando atributos da etapa 314\nAcessando atributos em um pipeline 315 pesquisado pela grade 315\nEtapas de pré-processamento de busca de grade e parâmetros do modelo 317\nPesquisa em grade qual modelo usar 319\nResumo e Outlook 320\n7. Trabalhando com dados de texto. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  323\nTipos de dados representados como Strings 323\nÍndice \n| \nv\nExemplo de aplicação: Análise de sentimentos de resenhas de filmes 325\nRepresentando os dados de texto como um saco de palavras 327\nAplicando o saco de palavras a um conjunto de dados de brinquedos 329\nBag de palavras para resenhas de filmes 330\nPalavras de parada 334\nDescalando os dados com TF - IDF 336\nInvestigação de coeficientes de modelo 338\nBag de palavras com mais de uma palavra (n-gramas) 339\nTokenização avançada, Stemming e Lemmatização 344\nModelagem de tópicos e cluster de documentos 347\nAlocação de Dirichlet latente 348\nResumo e Outlook 355\n8. encerrando. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  357\nAbordando um problema de aprendizado de máquina 357\nHumanos no loop 358\nDo protótipo à produção 359\nTestando sistemas de produção 359\nConstruindo seu próprio estimador 360\nPara onde ir daqui 361\nTeoria 361\nOutras estruturas e pacotes de aprendizado de máquina 362\nClassificação, sistemas de recomendação e outros tipos de aprendizado 363\nModelagem Probabilística, Inferência e Programação Probabilística 363\nRedes neurais 364\nEscala para conjuntos de dados maiores 364\nAprimorando suas habilidades 365\nConclusão 366\nÍndice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  367\nvi \n| \nÍndice\nPrefácio\nO aprendizado de máquina é parte integrante de muitas aplicações e pesquisas comerciais\nprojetos hoje, em áreas que variam de diagnóstico e tratamento médico até encontrar seu\nAmigos em redes sociais. Muitas pessoas pensam que o aprendizado de máquina só pode ser\nAplicado por grandes empresas com extensas equipes de pesquisa. Neste livro, queremos\nmostrar como é fácil criar soluções de aprendizado de máquina e como\nMelhor fazer isso. Com o conhecimento deste livro, você pode construir seu próprio sistema para\ndescobrir como as pessoas se sentem no Twitter ou fazendo previsões sobre Aquecimento global.\nAs aplicações do aprendizado de máquina são infinitas e, com a quantidade de dados disponíveis\nHoje, é possível, principalmente limitado pela sua imaginação.\nQuem deveria ler este livro\nEste livro é para atuais e aspirantes a profissionais de aprendizado de máquina que procuram\nImplementar soluções para problemas de aprendizado de máquina do mundo real. Este é um introdução\nLivro conservador que não requer conhecimento prévio de aprendizado de máquina ou intelli-\nGENCE (AI). Nós nos concentramos em usar o Python e a biblioteca Scikit-Learn e trabalhar\nAtravés de todas as etapas para criar um aplicativo de aprendizado de máquina de sucesso. A metanfetamina\nODS que apresentamos será útil para cientistas e pesquisadores, bem como cientções de dados -\nTists trabalhando em aplicações comerciais. Você vai tirar o máximo proveito do livro se você\nestão familiarizados com o Python e as bibliotecas Numpy e Matplotlib.\nFizemos um esforço consciente para não nos concentrar muito na matemática, mas sim no\naspectos práticos do uso de algoritmos de aprendizado de máquina. Como matemática (probabilidade\nteoria, em particular) é a base sobre a qual o aprendizado de máquina é construído, nós\nNão entrará na análise dos algoritmos em grande detalhe. Se você estiver interessado no\nMatemática dos algoritmos de aprendizado de máquina, recomendamos o livro The Elements\ndo aprendizado estatístico (Springer) de Trevor Hastie, Robert Tibshirani e Jerome\nFriedman, que está disponível gratuitamente no site dos autores. Também não vamos descrever\ncomo escrever algoritmos de aprendizado de máquina do zero e, em vez disso, se concentrará em\nvii\nComo usar a grande variedade de modelos já implementados no Scikit-Learn e outros\nBibliotecas.\nPor que escrevemos este livro\nExistem muitos livros sobre aprendizado de máquina e IA. No entanto, todos eles são feitos\npara estudantes de pós -graduação ou estudantes de doutorado em ciência da computação, e eles estão cheios de\nMatemática Avançada. Isso contrasta fortemente com a forma como o aprendizado de máquina está sendo\nUtilizado, como uma ferramenta de commodities em aplicações comerciais e de pesquisa. Hoje, aplicando\nO aprendizado de máquina não requer um doutorado. No entanto, existem poucos recursos por aí\nque abrangem totalmente todos os aspectos importantes da implementação do aprendizado de máquina em prac-\nTice, sem exigir que você faça cursos de matemática avançados. Esperamos que este livro\nAjude as pessoas que desejam aplicar o aprendizado de máquina sem ler os anos\nde cálculo, álgebra linear e teoria de probabilidade.\nNavegando este livro\nEste livro está organizado aproximadamente da seguinte maneira:\n• O capítulo 1 apresenta os conceitos fundamentais de aprendizado de máquina e seu\nAplicativos e descreve a configuração que usaremos ao longo do livro.\n• Os capítulos 2 e 3 descrevem os algoritmos reais de aprendizado de máquina que são mais\namplamente utilizado na prática e discuta suas vantagens e deficiências.\n• O capítulo 4 discute a importância de como representamos dados que são processados ​​por\naprendizado de máquina e quais aspectos dos dados prestarem atenção.\n• O capítulo 5 abrange métodos avançados para avaliação de modelos e ajuste de parâmetros,\ncom um foco particular na validação cruzada e pesquisa de grade.\n• O capítulo 6 explica o conceito de oleodutos para encadear modelos e encapsulat-\nseu fluxo de trabalho.\n• O capítulo 7 mostra como aplicar os métodos descritos nos capítulos anteriores ao texto\ndados e apresenta algumas técnicas de processamento específicas de texto.\n• O capítulo 8 oferece uma visão geral de alto nível e inclui referências a mais avançadas\nTópicos.\nEnquanto os capítulos 2 e 3 fornecem os algoritmos reais, entender tudo isso\nOs algoritmos podem não ser necessários para um iniciante. Se você precisar construir uma máquina\nSistema de aprendizado o mais rápido possível, sugerimos começar com o capítulo 1 e as seções de abertura de\nCapítulo 2, que introduz todos os conceitos principais. Você pode então pular para “Resumo e\nOutlook ”na página 127 no Capítulo 2, que inclui uma lista de todos os modelos supervisionados\nque nós cobrimos. Escolha o modelo que melhor se adapta às suas necessidades e volte para ler o\nviii \n| \nPrefácio"
    },
    "20160504_apostila_python__pet_ads_são_carlospdf": {
        "pdf": "INTRODUÇÃO À PROGRAMAÇÃO \nCOM PYTHON \n \n \n \n \n \n \n \nPrograma de Educação Tutorial \nGrupo PET - ADS   \nIFSP -  Câmpus São Carlos\nSumário \nPREFÁCIO ........................................................................................................................ 1 \n1. INTRODUÇÃO .............................................................................................................. 2 \n1.1 Características da linguagem Python ..................................................................... 2 \n1.2 Instalação do interpretador Python ....................................................................... 2 \n2. VARIÁVEIS ................................................................................................................... 4 \n3. STRINGS ...................................................................................................................... 6 \n3.1 Concatenação de strings ........................................................................................ 6 \n3.2 Manipulação de strings .......................................................................................... 7 \n3.3 Fatiamento de strings ............................................................................................ 8 \n3.4 Exercícios: strings .................................................................................................. 8 \n4. NÚMEROS ................................................................................................................... 9 \n4.1 Operadores numéricos .......................................................................................... 9 \n4.2 Exercícios: números ............................................................................................... 9 \n5. LISTAS ....................................................................................................................... 10 \n5.1 Funções para manipulação de listas .................................................................... 10 \n5.2 Operações com listas ........................................................................................... 11 \n5.3 Fatiamento de listas ............................................................................................ 11 \n5.4 Criação de listas com range ( ) ............................................................................. 12 \n5.5 Exercícios: listas ................................................................................................... 12 \n6. TUPLAS ..................................................................................................................... 13 \n7. DICIONÁRIOS ............................................................................................................ 13 \n7.1 Operações em dicionários ................................................................................... 14 \n7.2 Exercícios: dicionários .......................................................................................... 14 \n8. BIBLIOTECAS ............................................................................................................. 15 \n9. ESTRUTURAS DE DECISÃO ......................................................................................... 15 \n9.1 Estrutura if ........................................................................................................... 16 \n9.2 Estrutura if..else .................................................................................................. 16 \n9.3 Comando if..elif..else ........................................................................................... 16 \n9.4 Exercícios: estruturas de decisão ......................................................................... 17\n10. ESTRUTURAS DE REPETIÇÃO ................................................................................... 17 \n10.1 Laço while .......................................................................................................... 17 \n10.2 Laço for .............................................................................................................. 18 \n10.3 Exercícios: estrutura de repetição...................................................................... 19 \n11. FUNÇÕES ................................................................................................................ 19 \n11.1 Como definir uma função .................................................................................. 19 \n11.2 Parâmetros e argumentos ................................................................................. 19 \n11.3 Escopo das variáveis .......................................................................................... 20 \n11.4 Retorno de valores ............................................................................................ 20 \n11.5 Valor padrão ...................................................................................................... 21 \n11.6 Exercícios: funções............................................................................................. 21 \n12. RESPOSTAS DOS EXERCÍCIOS ................................................................................... 22 \nBIBLIOGRAFIA ............................................................................................................... 25\n1 \n \nPREFÁCIO \n \nEste material foi escrito para ser utilizado em cursos de extensão de Introdução à \nProgramação com Python, do Instituto Federal de Educação, Ciência e Tecnologia de \nSão Paulo, câmpus São Carlos. \nA apostila foi desenvolvida pelos integrantes do Programa de Educação Tutorial do curso \nde Tecnologia em Análise e Desenvolvimento de Sistemas - grupo PET ADS / IFSP São \nCarlos. O grupo iniciou suas atividades em 2011, e realiza atividades diversas envolvendo \nEnsino, Pesquisa e Extensão. Entre as linguagens e ferramentas de programação estudadas \npelo grupo estão: o ambiente de desenvolvimento Lazarus, o editor de jogos Construct 2, as \nlinguagens Ruby, Python e JavaScript, os frameworks Rails, Django, Web2Py e Grails.  \nA linguagem Python se destacou pela facilidade de programação e versatilidade. Python é \numa linguagem de uso geral, que pode ser utilizada para diversas aplicações. Apresenta \numa sintaxe simples, tornando os programas mais legíveis, o que também facilita o \naprendizado da linguagem. Possui listas, dicionários e tuplas como estruturas de dados \npré-definidas. É uma linguagem multiparadigma: suporta os paradigmas de programação \nprocedural, funcional e orientado a objetos.  \nDiversos petianos colaboraram na confecção desta apostila. Mas gostaria de agradecer \nespecialmente quatro estudantes que se destacaram pelo empenho e dedicação na \nexecução dessa tarefa: José Picharillo, Lucas Limão, Viviane Quinaia e Camila Couto.   \nEste é um material de apoio para um curso de extensão introdutório, cujo objetivo é \ndivulgar a linguagem Python. Não é um material preparado para autoaprendizagem, \nembora seja possível utilizá-lo com esse fim.  \nReforçando, este é um material introdutório. Tem muito mais para aprender em Python: \norientação a objetos, programação funcional, metaprogramação, interface gráfica, \nexpressões regulares, threads, tratamento de exceções, funções anônimas, geradores, \ndesenvolvimento web, aplicativos móveis, entre outras.  \nBem-vindo ao mundo Python! \n \n \n \nProf. Dr. João Luiz Franco \nTutor do grupo PET - ADS / São Carlos\n2 \n \n \n1. INTRODUÇÃO \n \n1.1 Características da linguagem Python \n \nA linguagem de programação Python foi criada em 1991 por Guido Van Rossumem, com a \nfinalidade de ser uma linguagem simples e de fácil compreensão. Apesar de simples, Python é uma \nlinguagem muito poderosa, que pode ser usada para desenvolver e administrar grandes sistemas. \n \nUma das principais características que diferencia a linguagem Python das outras é a legibilidade dos \nprogramas escritos. Isto ocorre porque, em outras linguagens, é muito comum o uso excessivo de \nmarcações (ponto ou ponto e vírgula), de marcadores (chaves, colchetes ou parênteses) e de \npalavras especiais (begin/end), o que torna mais difícil a leitura e compreensão dos programas. Já \nem Python, o uso desses recursos é reduzido, deixando a linguagem visualmente mais limpa, de \nfácil compreensão e leitura. \n \nEntre outras características existentes na linguagem Python, destaca-se a simplicidade da \nlinguagem, que facilita o aprendizado da programação. Python também possui uma portabilidade \nmuito grande para diversas plataformas diferentes, além de ser possível utilizar trechos de códigos \nem outras linguagens. \n \nPython é um software livre, ou seja, permite que usuários e colaboradores possam modificar seu \ncódigo fonte e compartilhar essas novas atualizações, contribuindo para o constante \naperfeiçoamento da linguagem. A especificação da linguagem é mantida pela empresa Python \nSoftware Foundation (PSF). \n \n \n1.2 Instalação do interpretador Python \n \na) Instalação de Python no Linux \n \nNas versões mais recentes do GNU/Linux, o Python já se encontra instalado, bastando ao \nprogramador entrar no terminal e digitar python. Caso não esteja, seguem os passos para a \ninstalação no terminal: \n \n1. Acesse o terminal Linux.\n3 \n \n2. Digite o comando sudo apt-get install python3.4 no terminal do GNU/Linux para inicializar \no processo de instalação. \n \n \n \n3. Terminado o download, o interpretador já estará instalado no computador. \n \n \n \n \nb) Instalação do IDLE no Linux \n \nO IDLE é um ambiente integrado de desenvolvimento que acompanha a instalação do interpretador \nPython em sistemas operacionais Windows. Para tê-lo disponível em distribuições Linux basta \nseguir as etapas abaixo: \n \n1. Acesse o terminal Linux. \n \n \n \n2. Digite o comando sudo apt-get install idle-python3.4. \n \n \n \n3. Para executá-lo basta digitar no terminal idle-python3.4 &.\n4 \n \nc) Instalação do Python no Windows \n \nA instalação do interpretador Python para Windows é mais simples, conforme apresentado a seguir: \n \n1. Entre no site www.python.org. Na aba download selecione a versão 3.5.1. \n \n2. Após o download, execute o instalador mantendo, por default, todas as configurações a cada \npasso da instalação. Depois clique em Finalizar e o interpretador Python já estará instalado \nno computador. \n \nCaso você não consiga executar o interpretador Python pelo prompt de comando, provavelmente o \npath não está configurado. Veja abaixo os passos para configurá-lo: \n \n1. Com o cursor do mouse vá até Computador, clique com o botão direito e escolha \nPropriedades. \n \n2. Depois clique em Configurações avançadas do sistema e, a seguir, Variáveis de ambiente. \n \n3. Com ajuda da barra de rolagem procure a variável chamada path, selecione-a e escolha a \nopção Editar. \n \n4. Na próxima janela, no campo Valor de variável, você irá encontrar uma lista contendo \nvários paths de outros programas. Para adicionar um novo path, vá até o final da lista e \nacrescente um ponto e vírgula ( ; ). Depois disso, copie o endereço da pasta onde se \nencontra instalado o interpretador Python e cole após ponto e vírgula. \n \n \n2. VARIÁVEIS \n \nVariáveis são pequenos espaços de memória, utilizados para armazenar e manipular dados. Em \nPython, os tipos de dados básicos são:  tipo inteiro (armazena números inteiros), tipo float (armazena \nnúmeros em formato decimal), e tipo string (armazena um conjunto de caracteres). Cada variável \npode armazenar apenas um tipo de dado a cada instante. \n \nEm Python, diferentemente de outras linguagens de programação, não é preciso declarar de que tipo \nserá cada variável no início do programa. Quando se faz uma atribuição de valor, automaticamente a \nvariável se torna do tipo do valor armazenado, como apresentado nos exemplos a seguir:  \n \nExemplos: \n \nA variável a se torna uma variável do tipo inteiro.\n5 \n \n \nA variável b se torna uma variável do tipo float. \n \nA variável c se torna uma variável do tipo string. \n \nA atribuição de valor para uma variável pode ser feita utilizando o comando input(), que \nsolicita ao usuário o valor a ser atribuído à variável. \n \nExemplo: \n \n \n \nO comando input(), sempre vai retornar uma string. Nesse caso, para retornar dados do tipo \ninteiro ou float, é preciso converter o tipo do valor lido. Para isso, utiliza-se o int (string) para \nconverter para o tipo inteiro, ou float (string) para converter para o tipo float. \n \n \nExemplos: \n \n \n \n \n \nEm Python, os nomes das variáveis devem ser iniciados com uma letra, mas podem possuir outros \ntipos de caracteres, como números e símbolos. O símbolo sublinha ( _ ) também é aceito no início \nde nomes de variáveis.\n6 \n \nTabela 1 - Exemplos de nomes válidos e inválidos \n \nNome \n \nVálido \n \nComentários \na3 \nSim \nEmbora contenha um número, o nome a3 inicia com letra. \nvelocidade \nSim \nNome formado com letras. \nvelocidade90 \nSim \nNome formado por letras e números, mas inicia com letras. \nsalario_médio \nSim \nO símbolo ( _ ) é permitido e facilita a leitura de nomes grandes. \nsalario médio \nNão \nNomes de variáveis não podem conter espaços em branco. \n_salário \nSim \nO sublinha ( _ ) é aceito em nomes de variáveis, mesmo no início. \n5A \nNão \nNomes de variáveis não podem começar com números. \n \n3. STRINGS \n \nUma string é uma sequência de caracteres simples. Na linguagem Python, as strings são utilizadas \ncom aspas simples ('... ') ou aspas duplas (\"...\").  \n \nPara exibir uma string, utiliza-se o comando print(). \n   \n Exemplo: \n \n \n \n3.1 Concatenação de strings \n \nPara concatenar strings, utiliza-se o operador +. Exemplo:\n7 \n \n3.2 Manipulação de strings \n \nEm Python, existem várias funções (métodos) para manipular strings.  Na tabela a seguir são \napresentados os principais métodos para a manipulação as strings. \n \nTabela 2 - Manipulação de strings \n \nMétodo \n \nDescrição \n \nExemplo \n \nlen() \nRetorna o tamanho da string. \nteste = “Apostila de Python” \nlen(teste) \n18 \n \ncapitalize() \nRetorna a string com a primeira letra maiúscula  \na = \"python\" \na.capitalize() \n'Python' \n \ncount() \nInforma quantas vezes um caractere (ou uma se-\nquência de caracteres) aparece na string. \nb = \"Linguagem Python\" \nb.count(\"n\") \n2 \n \nstartswith() \n \nVerifica se uma string inicia com uma determinada \nsequência.  \nc = \"Python\" \nc.startswith(\"Py\") \nTrue \n \nendswith() \nVerifica se uma string termina com uma determinada \nsequência. \nd = \"Python\" \nd.endswith(\"Py\") \nFalse \n \nisalnum() \nVerifica se a string possui algum conteúdo alfanu-\nmérico (letra ou número). \ne = \"!@#$%\" \ne.isalnum() \nFalse \n \nisalpha() \nVerifica se a string possui apenas conteúdo alfabéti-\nco. \nf = \"Python\" \nf.isalpha() \nTrue \n \nislower() \nVerifica se todas as letras de uma string são minús-\nculas. \ng = \"pytHon\" \ng.islower() \nFalse \n \nisupper() \nVerifica se todas as letras de uma string são maiús-\nculas.  \nh = \"# PYTHON 12\" \nh.isupper() \nTrue \n \nlower() \nRetorna uma cópia da string trocando todas as letras \npara minúsculo.  \ni = \"#PYTHON 3\" \ni.lower() \n'#python 3' \n \nupper() \nRetorna uma cópia da string trocando todas as letras \npara maiúsculo.  \nj = \"Python\" \nj.upper() \n'PYTHON' \n \nswapcase() \nInverte o conteúdo da string (Minúsculo / Maiúscu-\nlo). \nk = \"Python\" \nk.swapcase() \n'pYTHON' \n \ntitle() \nConverte para maiúsculo todas as primeiras letras de \ncada palavra da string. \nl = \"apostila de python\" \nl.title() \n'Apostila De Python' \n \nsplit() \nTransforma a string em uma lista, utilizando os es-\npaços como referência.  \nm = \"cana de açúcar\" \nm.split() \n['cana', 'de', 'açúcar']"
    },
    "introduçãoaoaprendizadodemáquinapdf": {
        "pdf": "[PSI5790-2025 aula 3 parte 2 – início]\nOs programas desta aula podem ser baixadas em Linux com os comandos:\n$ wget -U 'Firefox/50.0' http://www.lps.usp.br/hae/apostila/introaprend.zip  \n$ unzip introaprend.zip\nNota: O arquivo “procimagem.h” está em http://www.lps.usp.br/hae/apostila/procimagem.h.\nIntrodução ao Aprendizado de Máquina\nUma possível definição de aprendizado de máquina é:\nAprendizado de máquina é o estudo de algoritmos que executam uma certa tarefa base-\nando-se em exemplos, sem usar instruções explícitas. (definição de [Wiki\n \n p  edia\n \n ] adapta-\nda.)\nUma outra definição é:\n“Diz-se que um programa computacional aprende com a experiência E no que diz res-\npeito a uma tarefa T e medida de desempenho P, se o seu desempenho na tarefa T, me-\ndida por P, aumenta com a experiência E.” [Mitchell1997]\nO aprendizado de máquina divide-se em duas categorias principais:\n\nAprendizado supervisionado\n\nAprendizado não-supervisionado\nTambém existem técnicas que não se enquadram em nenhuma dessas duas categorias, como o\naprendizado auto-supervisionado. Neste curso, trataremos de somente aprendizado supervisio-\nnado.\n[Nota para mim:  Preciso melhorar esta apostila.\nAcrescentar exemplo de Breast Cancer Wisconsin \nhttps://www.kaggle.com/datasets/uciml/breast-cancer-wisconsin-data\nhttps://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html\n]\n1\n1. Aprendizado supervisionado: \nNo aprendizado supervisionado, um “professor” ou “oráculo” fornece amostras ou exemplos\nde treinamento de entrada/saída (ax, ay). O “aprendiz” ou “algoritmo de aprendizado” M clas-\nsifica uma nova instância de entrada qx baseado nos exemplos fornecidos pelo professor, ge-\nrando a classificação qp. Para cada instância de entrada qx existe uma classificação correta ou\nverdadeira qy, desconhecida pelo aprendiz. Se a classificação do aprendiz qp=M(qx) for igual\nà classificação verdadeira qy então dizemos que o aprendiz acertou a classificação. \nFigura: Esquema de aprendizado supervisionado.\nO método de aprendizado supervisionado mais usado hoje em dia é sem dúvida a rede neural\nartificial. Porém, existem muitos outros métodos clássicos de aprendizado supervisionado que\ncontinuam sendo usados. Nas próximas aulas, veremos alguns métodos clássicos juntamente\ncom suas aplicações.\nOpenCV possui várias rotinas clássicas de aprendizado implementadas que podem ser chama-\ndas de C/C++ ou de Python. Porém, muitas vezes, as rotinas da biblioteca SkLearn de Python\nsão mais confiáveis e flexíveis. Vamos usar as funções do OpenCV mas, quando toda vez que\nfor necessário, usaremos aquelas do SkLearn.\n2\n(ax,ay)\nM\nqx\nqp\nqy\n  Iguais?\nProblema ABC\nPara exemplificar o aprendizado de máquina, vamos considerar um problema muito simples:\n“Adulto”, “Bebê” ou “Criança” (ABC). \nO aprendiz (ou o algoritmo de aprendizado de máquina) M é alimentado com a tabela 1, com\nconjunto de exemplos de entrada-saída ou (ax, ay): \n{ (4,B), (15,C), (65,A), (5,B), (18,C), e (70,A) }. \nEste conjunto indica o peso em kg dos indivíduos e a sua classificação em “Adulto”, “Bebê”\nou “Criança”, mas o aprendiz M não sabe o que significam estes dados. Por exemplo (4,B) in-\ndica que há um indivíduo de 4 kg e sua classificação é “Bebê”. Depois, pede-se ao aprendiz M\nque classifique dado de teste qx=16 (tabela 2).\nTabela 1: Amostra de treinamento (ax, ay) do problema ABC.\nax (features, atributos, características, entradas)\nay (labels, rótulos, saídas, classificações)\n4\nB\n15\nC\n65\nA\n5\nB\n18\nC\n70\nA\nO aprendiz pode adotar diferentes técnicas para classificar o indivíduo com atributo qx=16.\nPorém, uma técnica “razoável” seria procurar na tabela aquela instância mais parecida com\n16. Fazendo isto, M encontra ax=15 cuja classificação é “C”. Então, M atribui rótulo “C” a\n16, isto é, M(16) = “C”, pois é razoável atribuir rótulos iguais a instâncias semelhantes. Este\nmétodo de aprendizado chama-se classificador vizinho mais próximo.\nEste método é denotado como k-NN, onde k indica quantos vizinhos mais próximos serão\nprocurados. O método descrito acima usa k=1, pois busca o vizinho mais próximo. Se k fosse\n3, procuraria 3 vizinhos mais próximos da instância de teste e calcularia a maioria dos votos\n(moda) desses 3 vizinhos.\nTabela 2: Instâncias de teste (qx), a classificação verdadeira (qy) e a classificação do aprendiz\n(qp).\nInstância  a  processar  ou  a\nclassificar (qx):\nClassificação  feita  pelo\naprendiz (qp):\nClassificação verdadeira des-\nconhecida (qy):\n16\nC\nC\n3\nB\nB\n75\nA\nA\n3 Implementação do problema ABC\nO programa abaixo resolve o problema ABC usando o classificador vizinho mais próximo im-\nplementado “manualmente” em C++, isto é, sem usar nenhuma função pronta de aprendizado\ndas bibliotecas. \n//abc2.cpp\n#include \"procimagem.h\"\nint main() {\n  Mat_<float> ax = (Mat_<float>(6,1) <<  4, 15, 65, 5, 18, 70);\n  Mat_<float> ay = (Mat_<float>(6,1) <<  1,  2,  0, 1,  2,  0);\n  Mat_<float> qx = (Mat_<float>(3,1) << 16,  3, 75);\n  Mat_<float> qy = (Mat_<float>(3,1) <<  2,  1,  0);\n  Mat_<float> qp(3,1);\n  for (int iq=0; iq<qx.rows; iq++) {\n    float menorDist=FLT_MAX, menorAy;\n    for (int ia=0; ia<ax.rows; ia++) {\n      float dist=abs(ax(ia)-qx(iq));\n      if (dist<menorDist) { menorDist=dist; menorAy=ay(ia); }\n    }\n    qp(iq)=menorAy;\n  }\n  cout << \"qp:\\n\" << qp << endl;\n  cout << \"qy:\\n\" << qy << endl;\n}\nPrograma P1: abc2.cpp.\nExecutando o programa, obtemos:\nqp: [2; 1; 0]  // Saidas geradas pelo programa\nqy: [2; 1; 0]  // Rotulos verdadeiros\nonde os rótulos 0, 1 e 2 representam respectivamente A, B e C. O programa conseguiu classi-\nficar corretamente os três indivíduos de pesos 16, 3 e 75 kg em C, B, A.\nExercício: Traduza o programa abc2.cpp para Python.\nExercício: Adapte o programa abc2.cpp para resolver o problema de classificação ABC quando é fornecida a al-\ntura do indivíduo em cm (em vez de peso).\nAmostra de treinamento (ax, ay):\nax (features, características, entradas)\nay (labels, rótulos, saídas, classificações)\n46\nB\n120\nC\n165\nA\n51\nB\n110\nC\n173\nA\nInstâncias a classificar (qx) e classificação verdadeira (qy).\nInstância a processar ou a classificar (qx):\nClassificação ideal ou verdadeira (qy):\n60\nB\n168\nA\n105\nC\n4\nProblema ABC com cor da pele\nConsidere novamente o problema de classificar um indivíduo como “Adulto”, “Bebê” ou\n“Criança”, mas desta vez são dados como entrada o peso em kg e a cor da pele (0 = escura,\n100 = clara). Evidentemente, a cor da pele não tem nada a ver com a classificação A, B ou C,\nmas o algoritmo M não sabe disso.\nTabela 3: Amostra de treinamento (ax, ay) do problema ABC com cor da pele.\nax \nay \npeso\ncor da pele\n4\n90\nB\n15\n50\nC\n65\n70\nA\n5\n7\nB\n18\n3\nC\n70\n80\nA\nTabela 4: Dados de teste (qx, qy) do problema ABC com cor da pele.\nqx \nqp (vizinho + px)\nqy \npeso\ncor da pele\n20\n6\nC\nC\n16\n80\nB\nC\n68\n3\nC\nA\n80\n20\nA\nA\n7\n70\nB\nB\n3\n50\nC\nB\nNota para mim: Programas em ~/algpi/introaprend/pele\nRepare na tabela acima que o algoritmo do vizinho mais próximo irá cometer 3 erros (marca-\ndos em amarelo). Na figura X, os pontos “o” são os dados de treino e os pontos “x” são os da-\ndos de teste. Os pontos “x” marcados em amarelo são dados de teste classificados incorreta-\nmente. O que se deve fazer para classificar corretamente todas as instâncias de teste?\n5\npeso (kg)\ncor da pele\nFigura X: Pontos “o” indicam dados de treino. Pontos “x” indicam dados de teste. Vermelho é\nAdulto, verde é Bebê e azul é Criança. Os pontos marcados com retângulo amarelo indicam\ndados de teste que serão classificados incorretamente.\nExercício: Modifique o programa abc2.cpp acima para resolver o problema “ABC com cor de\npele” e verifique que o programa realmente comete 3 erros.\nSolução no arquivo abc2-pele.cpp.\n6\nÁrvore de decisão\nSeria possível que algum método de aprendizado de máquina consiga descobrir por si só que\na “cor da pele” não influencia se o indivíduo é Adulto, Bebê ou Criança? A árvore de decisão\nconsegue. Vamos resolver o problema “ABC com cor da pele” usando árvore de decisão.\nA árvore de decisão faz sucessivos cortes no espaço dos atributos. Ela escolhe um atributo e\num valor que mais ajudam a resolver o problema de classificação. Existem vários métodos di-\nferentes para escolher o melhor atributo e valor de corte [Wikipedia]. Uma possibilidade é cal-\ncular “ganho de informação” ou “redução de entropia” ou “índice Gini” (veja anexo A).\nVou dar uma explicação intuitiva do ganho de informação. Considere o nosso problema da se-\nção anterior com 6 amostras de treino: {2 Adultos, 2 Bebês e 2 Crianças}. Se, ao fazermos o\nprimeiro corte, obtivermos dois subconjuntos com {1 Adulto, 1 Bebê e 1 Criança}, esse corte\nnão ajudou em nada a resolver o problema de classificação. Porém, se o corte fizer resultar\nnos subconjuntos {2 Adultos, 0 Bebê e 0 Criança} e {0 Adulto, 2 Bebês e 2 Crianças}, ele se-\nparou Adultos das demais categorias, ajudando a resolver o problema (houve ganho de infor-\nmação ou redução de desordem). A árvore de decisão procura escolher cortes que ajudem ao\nmáximo a resolver o problema.\nA implementação da árvore de decisão em OpenCV não é muito boa. Assim, vamos usar a\nimplementação de Python/SkLearn.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n#dt2-pele.py\nimport numpy as np\nfrom sklearn import tree\nimport matplotlib.pyplot as plt\nax = np.matrix(\"4 90; 15 50; 65 70; 5 7; 18 3; 70 80\",dtype=np.float32)\nay = np.matrix(\"1;  2;  0; 1;  2;  0\",dtype=np.float32)\nqx = np.matrix(\"20 6;  16 80; 68 8; 80 20; 7 70; 3 50\",dtype=np.float32)\nqy = np.matrix(\" 2; 2; 0; 0; 1; 1\",dtype=np.float32)\narvore= tree.DecisionTreeClassifier()\narvore= arvore.fit(ax, ay)\nqp=arvore.predict(qx)\nprint(\"qp: \", qp)\nprint(\"qy: \", np.ravel(qy))\nfig=plt.figure(figsize=(8,6))\ntree.plot_tree(arvore,filled=True,fontsize=10)\nplt.tight_layout()\nplt.show()\nfig.savefig(\"dt2-pele.png\")\nPrograma P2: dt2-pele.py.\nEste programa resolveu perfeitamente o problema “ABC com cor de pele”:\nqp:  [2. 2. 0. 0. 1. 1.]\nqy:  [2. 2. 0. 0. 1. 1.]\n7\nA biblioteca SkLearn pode mostrar a árvore gerada:\nFigura: A árvore de decisão gerada pelo programa usando SkLearn/Python.\n8\nFigura: Superfície de decisão da árvore de decisão, com pesos (x) e cores da pele (y). Pontos “o” indi-\ncam dados de treino. Pontos “x” indicam dados de teste classificados corretamente por vizinho mais\npróximo. Pontos “■” indicam dados de teste classificados incorretamente por vizinho mais próximo.\nVermelho é Adulto, verde é Bebê e azul é Criança. As linhas vermelho e verde indicam as duas linhas\nde corte.\nObservando as figuras acima, descobrimos que os dois cortes foram feitos no eixo x (peso) e\nos valores das cortes são 10 (linha vermelha que separa Bebê de Crianças/Adultos) e 41.5 (li-\nnha verde que separa Crianças de Adultos). Nenhum corte foi feita no eixo y (cor de pele)\npois este atributo é inútil para a classificação.\nDada uma instância a classificar, por exemplo qx=[20, 6], a árvore de decisão verifica se o\nprimeiro atributo (X[0]=20) é <=10. Como é 20>10, navega para a sub-árvore da direita. Ago-\nra, verifica se o primeiro atributo (X[0]=20) é <=41.5. Como 20<41.5, navega para o nó da\nesquerda (em roxo). Nesse nó, estão armazenadas 2 exemplos de treino da classe “2” (value =\n[0, 0, 2]). Portanto, qx=[20, 6] é classificada pela árvore de decisão como classe “2”, isto é,\nM([20, 6])=“2”  ou qp=“2”.\n9\nExercício: Adapte o programa dt2-pele.py para resolver o problema de classificação ABC com cor da pele quan-\ndo é fornecida a altura do indivíduo em cm (em vez de peso).\nax \nay \naltura\ncor da pele\n46\n90\nB\n120\n50\nC\n165\n70\nA\n51\n7\nB\n110\n3\nC\n173\n80\nA\nqx \nqy \naltura\ncor da pele\n102\n6\nC\n124\n80\nC\n168\n3\nA\n176\n20\nA\n44\n70\nB\n61\n50\nB\n10"
    },
    "machinelearningempythonpdf": {
        "pdf": "Apostila de Machine Learning \n \nPor William Ludovico Homem \nPET Engenharia Mecânica Ufes\nUNIVERSIDADE FEDERAL DO ESPÍRITO SANTO \nPROGRAMA DE EDUCAÇÃO TUTORIAL ENGENHARIA MECÂNICA \n \n \n \n \n \n \nWILLIAM LUDOVICO HOMEM \n \n \n \n \n \n \nAPOSTILA DE MACHINE LEARNING \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nVITÓRIA \n2020\nSUMÁRIO \n1. INTRODUÇÃO ............................................................................................................ 4 \n2. PYTHON E SUAS BIBLIOTECAS ............................................................................ 4 \n2.1. GOOGLE COLABORATORY ............................................................................. 5 \n2.2. SINTAXE E ESTRUTURAS DE DADOS ........................................................... 6 \n2.3. BIBLIOTECAS ................................................................................................... 12 \n2.3.1. NUMPY ........................................................................................................ 13 \n2.3.2. MATPLOTLIB ............................................................................................. 15 \n3. APRENDIZAGEM DE MÁQUINA .......................................................................... 18 \n3.1. CONCEITOS GERAIS ....................................................................................... 19 \n3.2. DESCIDA DO GRADIENTE ............................................................................. 22 \n3.3. REDES NEURAIS .............................................................................................. 26 \n3.3.1. BACKPROPAGATION ............................................................................... 30 \n4. ESTUDO DE CASO: DADOS MNIST ..................................................................... 32 \n4.1. PRÉ-PROCESSAMENTO E ANÁLISE EXPLORATÓRIA ............................. 32 \n4.2. CRIAÇÃO E TREINAMENTO DO MODELO ................................................. 37 \n5. REFERÊNCIAS BIBLIOGRÁFICAS ....................................................................... 46\n1. INTRODUÇÃO \nO curso de Machine Learning tem o objetivo de apresentar os conceitos básicos por trás \ndo uso de Aprendizagem de Máquina por meio da construção de uma aplicação que será \nusada para identificar dígitos manuscritos. Para tanto, toda a programação será auxiliada \npor bibliotecas escritas em Python, como Numpy, Matplotlib e TensorFlow. \nAs aulas, bem como essa apostila, serão divididas em dois grandes módulos. O primeiro \nserá voltado para apresentação da linguagem Python, sua sintaxe e suas estruturas. Vale \nressaltar, entretanto, que será feito apenas um apanhado geral da linguagem. O objetivo \ndessa seção é apresentar o conteúdo básico que será usado no estudo de caso. \nNo segundo módulo, por sua vez, será criado um algoritmo capaz de identificar números \nescritos à mão, oriundos do MNIST Dataset. No decorrer do desenvolvimento, serão \napresentadas as estruturas básicas presentes em redes feedfoward, assim como o seu \nfuncionamento. \nEspera-se que, ao término do curso, o congressista tenha ciência da filosofia por trás dessa \nárea da Inteligência Artificial e possa, posteriormente, ter uma aprendizagem facilitada \nsobre modelos mais complexos e usuais, além de trabalhar em seus próprios projetos e \nbanco de dados. \n \n2. PYTHON E SUAS BIBLIOTECAS\nAntes de discutir sobre Aprendizagem de Máquina, é necessária a definição de uma \nlinguagem de programação para que o modelo possa ser escrito e processado por um \ncomputador. Dentre as muitas existentes, opta-se pela utilização da linguagem Python, \npor ser amplamente utilizada no campo de Ciência de Dados e Machine Learning, graças \nao advento de bibliotecas como Pandas, TensorFlow e Keras. \nPython foi concebido no final de 1989 por Guido van Rossum e se popularizou por ser \numa das primeiras linguagens a trazer o conceito de Orientação a Objeto. Com uma \nfilosofia simplista e explícita, essa linguagem open source, hoje, é classificada como uma \nlinguagem de alto nível, interpretada, imperativa, orientada a objetos e de tipagem \ndinâmica e forte. \n“Beautiful is better than ugly. \nExplicit is better than implicit. \nSimple is better than complex. \nComplex is better than complicated. \nFlat is better than nested.\nSparse is better than dense. \nReadability counts. \nSpecial cases aren't special enough to break the rules. \nAlthough practicality beats purity. \nErrors should never pass silently. \nUnless explicitly silenced. \nIn the face of ambiguity, refuse the temptation to guess. \nThere should be one-- and preferably only one --obvious way to \ndo it. \nAlthough that way may not be obvious at first unless you're \nDutch. \nNow is better than never. \nAlthough never is often better than *right* now. \nIf the implementation is hard to explain, it's a bad idea. \nIf the implementation is easy to explain, it may be a good idea. \nNamespaces are one honking great idea -- let's do more of \nthose!” (PETERS, 2004) \nEsse capítulo, então, tem como objetivo ilustrar a sintaxe e as estruturas básicas da \nlinguagem Python, visando, assim, um maior entendimento do congressista no que se \nrefere aos assuntos dos capítulos posteriores. \n \n2.1. GOOGLE COLABORATORY \nConhecido, também, como Google Colab, o Google Colaboratory é um ambiente de \nprogramação Jupyter que permite que o usuário crie programas escritos em Python \ndiretamente do navegador, sem nenhuma configuração prévia ou instalação de bibliotecas \nfamosas. Além disso, a plataforma permite uma interação direta com o Google Drive e \noferece o requerimento de processamento paralelo de GPU’s ou TPU’s sem a necessidade \nde posse desses hardwares. \nPor essas funcionalidades e facilidades, o curso de Machine Learning e essa apostila \nutilizará esse ambiente. Entretanto, o Google Colab será tratado como uma ferramenta e, \nportanto, esse texto não abordará especificidades da plataforma.\n2.2. SINTAXE E ESTRUTURAS DE DADOS \nEm Python, tudo é objeto. Dessa forma, todos os dados são estruturados de forma a \npossuir função e característica. Embora a Orientação a Objeto não se enquadre na \nabordagem desse curso, é muito aconselhável que o leitor se inteire sobre o assunto para \nque o entendimento da linguagem se torne mais orgânico. \nEmbora a afirmação feita no parágrafo acima seja generalizada, os dados podem possuir \nclassificações distintas. Os valores numéricos, por exemplo, são divididos em inteiros \n(integer ou int) e flutuantes (float). \nQuadro 1: Variáveis Numéricas. \nnum_int = 10 \nnum_float = 10.1 \n \nprint(f'As variáveis \"num_int\" e \"num_float\" são, \nrespectivamente, do tipo {type(num_int)} e \n{type(num_float)}.') \n \n \nAs variáveis \"num_int\" e \"num_float\" são, \nrespectivamente, do tipo <class 'int'> e <class 'float'>. \nFonte autoral. \nO Quadro 1 ilustra a saída de uma célula do Google Colab. Observe que os valores “10” \ne “10.1” foram atribuídos a duas variáveis distintas que, posteriormente, foram utilizadas \nna função “print”, que imprime uma mensagem na tela. Essa função, por usa vez, requer \ncomo parâmetro alguma estrutura de texto (string) que é definida entre aspas simples ou \nduplas.  \nNote, entretanto, que, antes da string, foi acrescentada a letra “f”. Esse acréscimo é um \natalho para o uso do método “.format” utilizado para manipular dados do tipo string e, \nnesse caso, permitiu que fosse acrescido ao texto os valores das variáveis declaradas, \ninclusas no texto entre chaves. Um outro exemplo da utilização do método “.format” é \nilustrado no Quadro 2. \nAinda se tratando do Quadro 1, a função “type” foi utilizada para que fosse retornado o \ntipo das variáveis declaradas. O retorno da função demonstra que ambas são objetos \n(class), mas um valor é do tipo inteiro e o outro flutuante. \nQuadro 2: Método “.format”. \nnome = 'William' # A variável \"nome\" carrega o valor de \numa string\nprint('Olá, {}.'.format(nome)) # Método \".format\". A \nvariável nome irá assumir a posição das chaves. \nprint(f'Olá, {nome}.') # Método abreviado. \n \n \nOlá, William. \nOlá, William. \nFonte Autoral \nO conjunto de valores que em outras linguagens é conhecido como vetor, ou matriz, \npossui um paralelo com as listas, em Python. A distinção no nome vem a calhar uma vez \nque as listas permitem a junção de valores distintos, o que não é possível em muitas outras \nlinguagens de programação. Sua declaração e exemplificação podem ser estudadas por \nintermédio do Quadro 3. \nQuadro 3: Listas. \nlista_numerica = [1,2,3,4,5,6] \nlista_misturada = ['William', '24'] \n \nprint(f'Lista numérica: {lista_numerica}') \nprint(f'Lista misturada: {lista_misturada}') \n \n# A indexação das listas se dá por meio dos colchetes. \nnome = lista_misturada[0] \nidade = lista_misturada[1] \n \nprint(f'Bem vindo, {nome}. Você tem, realmente, {idade} \nanos?') \n \n \nLista numérica: [1, 2, 3, 4, 5, 6] \nLista misturada: ['William', '24'] \nBem vindo, William. Você tem, realmente, 24 anos? \nFonte autoral. \nEnquanto as listas podem ser modificadas e manipuladas (métodos “.append”, “.remove” \ne “.sort”, por exemplo), há, ainda, conjuntos de dados imutáveis: as tuplas. As tuplas são \ndefinidas entre parênteses e não admitem, como comentado, nenhuma manipulação, \ncomo ilustra a Quadro 4. \nQuadro 4: Tuplas. \n# Listas \nlista = [4,1,2,4] \nprint(f'Lista desordenada: {lista}.') \n \nlista.sort()\nprint(f'Lista ordenada: {lista}.') \n \nprint('\\n') \n \n# Tuplas \ntup = (4,1,2,4) \nprint(f'Tupla: {tup}.') \n \ntup.sort() \n \n \nLista desordenada: [4, 1, 2, 4]. \nLista ordenada: [1, 2, 4, 4]. \n \n \nTupla: (4, 1, 2, 4). \n---------------------------------------------------------\n--------------------------------------------------------- \nAttributeError          Traceback (most recent call last) \n<ipython-input-11-e28a6babb39a> in <module>() \n     12 print(f'Tupla: {tup}.') \n     13  \n---> 14 tup.sort() \n \nAttributeError: 'tuple' object has no attribute 'sort' \n \nFonte autoral. \nVisto alguns dos muitos tipos de dados contidos na linguagem Python, é natural a \nabordagem dos operadores. A Tabela 1 e 2 mostram os operadores matemáticos e lógicos, \nrespectivamente, mais comumente utilizados. \nTabela 1: Operadores Matemáticos. \nOperação \nResultado \n𝑥+ 𝑦 \nSoma de 𝑥 e 𝑦 \n𝑥−𝑦 \nSubtração de 𝑥 e 𝑦 \n𝑥∗𝑦 \nMultiplicação de 𝑥 po 𝑦 \n𝑥/𝑦 \nDivisão de 𝑥 por 𝑦 \n𝑥//𝑦 \nQuociente flutuante de 𝑥 por 𝑦 \n𝑥%𝑦 \nResto de 𝑥/𝑦 \n𝑐𝑜𝑚𝑝𝑙𝑒𝑥(𝑟𝑒, 𝑖𝑚) \nNúmero complexo com parte real igual a \n𝑟𝑒 e parte imaginária igual a 𝑖𝑚 \n𝑥∗∗𝑦 \nPotência de 𝑥 por 𝑦 \nFonte: docs.python.org\nTabela 2: Operadores Lógicos. \nOperação \nSignificado \n< \nMenor \n> \nMaior \n<= \nMenor ou igual \n>= \nMaior ou igual \n== \nIgual \n! = \nDiferente \n𝑥 𝑜𝑟 𝑦 \nSe 𝑥 ou 𝑦 forem verdadeiros, retorna \nverdadeiro \n𝑥 𝑎𝑛𝑑 𝑦 \nSe 𝑥 e 𝑦 forem verdadeiros, retorna \nverdadeiro \n𝑛𝑜𝑡 𝑥 \nSe 𝑥 for verdadeiro, retorna falso. Se 𝑥 \nfor falso, retorna verdadeiro. \nFonte: docs.python.org \nTendo o conhecimento de como operar e manipular os dados de forma matemática e \nlógica, pode-se definir estruturas mais robustas e úteis. As estruturas condicionais, por \nexemplo, são de grande utilidade e podem ser facilmente criadas pela palavra reservada \n“if”, como ilustra o Quadro 5. Note que após a condição há a pontuação “dois pontos”, \nsinalizando a consequência da condicional. Essa, por sua vez, deve ficar recuada à \nesquerda por um “tab”; a indentação em Python é parte de sua sintaxe. \nQuadro 5: Estrutura Condicional. \nnum = input('Digite um número:\\n') # Função que registra \num valor do usuário \nnum = int(num) # Transforma o valor em um inteiro \n \nif num < 0: \n  print('O fatorial de um número negativo não é definido.\n') \nelif num == 0: \n  fat = 1 \nelse: \n  pass \n \n \nDigite um número: \n5\nFonte autoral. \nNote que no exemplo há a utilização de duas funções ainda não apresentadas: “input” e \n“int”. A primeira recebe um registro feito pelo usuário por meio do teclado e a segunda \ntransforma aquele valor em um inteiro (as funções “float” e “string” possuem fins \nsimilares). Há, ainda, junto à estrutura condicional, o “elif”, que é verificado apenas após \na verificação do “if”, e o “else”, que é executado apenas se as condições não forem \nsatisfeitas. \nPode-se observar no Quadro 5 que o código ali contido tem o objetivo de calcular o \nfatorial de um número. É necessária, então, a inserção de um código no bloco “else” que, \nde fato, calcule essa operação. Para tanto, pode-se utilizar a estrutura de repetição “for”. \nQuadro 6: Estrutura de Repetição “for”. \nnum = input('Digite um número:\\n') # Função que registra \num valor do usuário \nnum = int(num) # Transforma o valor em um inteiro \nfat = 1 # Inicialização da variável \"fat\" \n \nif num < 0: \n  print('O fatorial de um número negativo não é definido.\n') \nelif num == 0: \n  fat = 1 \nelse: \n  for i in range(1, num + 1): \n    fat *= i \n \nprint(f'O fatorial de {num} é {fat}.') \n \n \nDigite um número: \n5 \nO fatorial de 5 é 120. \nFonte autoral. \nO Quadro 6 traz, além da estrutura “for”, um tipo de dado chamado “range”, que organiza \num conjunto de números igualmente espaçados e pertencentes ao conjunto \n[𝑛º 𝑖𝑛𝑖𝑐𝑖𝑎𝑙, 𝑛º 𝑓𝑖𝑛𝑎𝑙). A linha “𝑓𝑎𝑡 ∗= 𝑖” é uma forma abreviada de se escrever “𝑓𝑎𝑡 =\n 𝑓𝑎𝑡 ∗ 𝑖”. Há, além do “for”, uma outra estrutura de repetição comum chamada “while”, \nilustrada no Quadro 7. \nQuadro 7: Estrutura de Repetição “while”. \nnum = 1"
    }
}